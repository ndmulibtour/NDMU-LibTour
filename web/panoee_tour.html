<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NDMU Virtual Tour</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #pano {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
    }
    #loading-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1B5E20 0%, #2E7D32 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.4s ease;
    }
    #loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .spinner {
      border: 4px solid rgba(255,255,255,0.3);
      border-top: 4px solid #FFA000;
      border-radius: 50%;
      width: 60px; height: 60px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-text {
      color: white;
      margin-top: 24px;
      font-size: 20px;
      font-weight: 600;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .loading-location {
      color: #FFA000;
      margin-top: 12px;
      font-size: 18px;
      font-weight: 500;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
  </style>
</head>
<body>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading Virtual Tour</div>
    <div class="loading-location" id="location-text">NDMU University Library</div>
  </div>

  <div id="pano"></div>

  <script src="/panoee/static/core/tour.js"></script>
  <script>
    // ===== CONFIGURATION =====
    var STATIC_BASE = '/panoee/';

    var currentScene = null;
    var krpanoObj = null;
    var tourData = null;
    var tourReady = false;

    // Fallback scene names for known scenes
    var sceneNames = {
      '6978265df7083ba3665904a6': 'NDMU Library',
      '697825f6f7083bc155590495': 'Library Entrance',
      '6978296b70f11a7b5a1085f6': 'CSCAM & Archives',
      '697858a270f11a45ea108937': 'Law School Library',
      '697863c0f7083b566c5908c8': 'Graduate School Library',
      '6978668770f11a701b108aaa': 'EMC',
      '6982e78b9da68288a5139bef': 'Filipiniana Section',
      '6982f3539da68242ef139c80': 'Director of Libraries',
      '6982f3539822ba02d869d6d8': 'Technical Section',
      '6982f3769822ba124369d6db': 'Internet Section',
      '6982f9b89822ba2cbf69d736': 'Main Section',
      '698307b16fccac7e5ec6d72d': 'Discussion Room'
    };

    var loadingOverlay = document.getElementById('loading-overlay');
    var locationText = document.getElementById('location-text');

    // Get a safe display name for a scene
    function getSceneName(sceneId) {
      if (tourData) {
        for (var i = 0; i < tourData.length; i++) {
          if (tourData[i].id === sceneId) {
            return tourData[i].name || tourData[i].title || sceneNames[sceneId] || 'Scene';
          }
        }
      }
      return sceneNames[sceneId] || 'Scene';
    }

    // ===== LOAD TOUR DATA =====
    function loadTourData(callback) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', STATIC_BASE + 'db.json?t=' + Date.now(), true);
      xhr.onload = function() {
        if (xhr.status === 200) {
          try {
            var dbData = JSON.parse(xhr.responseText);
            console.log('Tour data loaded successfully');

            if (dbData.pageProps && dbData.pageProps.initialState) {
              tourData = dbData.pageProps.initialState.app.listScene;
              console.log('Loaded ' + tourData.length + ' scenes from cache pageProps');
            } else if (dbData.scenes && dbData.scenes.length > 0) {
              tourData = dbData.scenes;
              console.log('Loaded ' + tourData.length + ' scenes from db.json scenes');
            } else if (dbData.cache_file) {
              var cacheXhr = new XMLHttpRequest();
              cacheXhr.open('GET', STATIC_BASE + dbData.cache_file + '?t=' + Date.now(), true);
              cacheXhr.onload = function() {
                if (cacheXhr.status === 200) {
                  var cacheData = JSON.parse(cacheXhr.responseText);
                  if (cacheData.pageProps && cacheData.pageProps.initialState) {
                    tourData = cacheData.pageProps.initialState.app.listScene;
                  } else if (cacheData.scenes) {
                    tourData = cacheData.scenes;
                  }
                  console.log('Loaded ' + (tourData ? tourData.length : 0) + ' scenes from cache file');
                  callback();
                }
              };
              cacheXhr.send();
              return;
            }
            callback();
          } catch (e) {
            console.error('Failed to parse db.json:', e);
          }
        } else {
          console.error('Failed to load db.json:', xhr.status);
        }
      };
      xhr.send();
    }

    // ===== FIND A SCENE BY ID =====
    function findSceneById(sceneId) {
      if (!tourData) return null;
      for (var i = 0; i < tourData.length; i++) {
        if (tourData[i].id === sceneId) return tourData[i];
      }
      return null;
    }

    // ===== BUILD KRPANO XML FOR A SCENE =====
    function buildSceneXml(scene, targetView) {
      if (!scene || !scene.media || !scene.media.krpano_xml) return null;

      var krpanoXml = scene.media.krpano_xml;

      // Fix image paths - make them absolute
      if (krpanoXml.indexOf('https://') === -1) {
        krpanoXml = krpanoXml.replace(/static\/media\//g, STATIC_BASE + 'static/media/');
        krpanoXml = krpanoXml.replace(/url="static\//g, 'url="' + STATIC_BASE + 'static/');
      }

      // Use targetView if provided (hotspot navigation), otherwise fall back to scene default
      var hlookat = 0, vlookat = 0, fov = 110;
      if (targetView) {
        var tvParts = targetView.split('|');
        if (tvParts.length >= 2) {
          hlookat = parseFloat(tvParts[0]) || 0;
          vlookat = parseFloat(tvParts[1]) || 0;
          // Clamp FOV: ignore any value outside [100, 130], always default to 110
          var rawFov = parseFloat(tvParts[2]);
          fov = (rawFov >= 100 && rawFov <= 130) ? rawFov : 110;
        }
      } else if (scene.config && scene.config.default_view) {
        hlookat = scene.config.default_view.x || 0;
        vlookat = scene.config.default_view.y || 0;
      }

      // Zoom limits â€” fixed: min 100, max 130
      var fovmin = 100, fovmax = 130;

      // Build hotspot XML
      var NAVPOINT_ATV = 25;    // Fixed vertical angle for ground hotspots
      var CHEVRON_ATV = 25;     // Chevron position vertical angle
      var CHEVRON_DIST = 200;   // Distance between chevron and hotspot center

      var hotspotsXml = '';
      if (scene.hotspots && scene.hotspots.length > 0) {
        for (var i = 0; i < scene.hotspots.length; i++) {
          var hs = scene.hotspots[i];

          if (hs.config && hs.config.chevron && hs.config.chevron.target_scene_id) {
            var targetId = hs.config.chevron.target_scene_id;
            var hsAth = hs.ath || 0;

            // Build the target view for lookto after navigation
            var targetView = '';
            var chev = hs.config.chevron;
            if (chev.hlookat_default !== undefined && chev.vlookat_default !== undefined) {
              // Always clamp zoom_default to [100, 130]; fall back to 110
              var zd = parseFloat(chev.zoom_default);
              var safeZoom = (zd >= 100 && zd <= 130) ? zd : 110;
              targetView = chev.hlookat_default + '|' + chev.vlookat_default + '|' + safeZoom;
            }

            hotspotsXml += '  <hotspot name="hs_nav_' + i + '" ' +
              'type="image" ' +
              'url="' + STATIC_BASE + 'static/core/plugins/garrows/hotspot.png" ' +
              'ath="' + hsAth + '" ' +
              'atv="' + CHEVRON_ATV + '" ' +
              'width="80" height="80" ' +
              'scale="1.5" ' +
              'edge="center" ' +
              'distorted="true" ' +
              'rx="70" ' +
              'oy="-10" ' +
              'rotate="' + (hs.rotate || 0) + '" ' +
              'alpha="1.0" ' +
              'onover="tween(alpha, 0.8, 0.3);" ' +
              'onout="tween(alpha, 1.0, 0.3);" ' +
              'onclick="jscall(navigateToSceneFromKrpano(\'' + targetId + '\', \'' + targetView + '\'))" ' +
              '/>\n';
          }
        }
      }

      // Full krpano XML - image, view, and hotspots directly under <krpano>
      var xml = '<krpano>\n' +
        '  <display multiresthreshold="-0.5" />\n' +
        '  <view hlookat="' + hlookat + '" vlookat="' + vlookat + '" fov="' + fov + '" ' +
        'fovmin="' + fovmin + '" fovmax="' + fovmax + '" fovtype="MFOV" maxpixelzoom="1.0" />\n' +
        '  ' + krpanoXml + '\n' +
        hotspotsXml +
        '</krpano>';

      return xml;
    }

    // ===== NAVIGATE TO A SCENE =====
    function navigateToScene(sceneId, sceneName, targetView) {
      var displayName = sceneName || getSceneName(sceneId);
      console.log('Navigating to scene:', displayName, '(' + sceneId + ')');
      currentScene = sceneId;

      locationText.textContent = displayName;
      loadingOverlay.classList.remove('hidden');

      var scene = findSceneById(sceneId);
      if (!scene) {
        console.error('Scene not found in tourData:', sceneId);
        loadingOverlay.classList.add('hidden');
        return;
      }

      var xml = buildSceneXml(scene, targetView);
      if (!xml) {
        console.error('Could not build XML for scene:', sceneId);
        loadingOverlay.classList.add('hidden');
        return;
      }

      if (krpanoObj) {
        // Remove existing navigation hotspots and arrows before loading new scene
        try {
          var hsCount = krpanoObj.get('hotspot.count');
          for (var hi = hsCount - 1; hi >= 0; hi--) {
            var hsName = krpanoObj.get('hotspot[' + hi + '].name');
            if (hsName && (hsName.indexOf('hs_nav_') === 0 || hsName.indexOf('hs_arrow_') === 0)) {
              krpanoObj.call('removehotspot(' + hsName + ')');
            }
          }
        } catch(e) {}

        // Load XML safely via krpano variable to prevent XML parse errors
        krpanoObj.set('xmldata', xml);
        krpanoObj.call('loadxml(get(xmldata), null, MERGE, BLEND(0.7))');

        setTimeout(function() {
          loadingOverlay.classList.add('hidden');
          // H-2: send only to our known parent origin, never '*'
          window.parent.postMessage({ 
            type: 'tourLoaded', 
            scene: currentScene,
            name: displayName
          }, PARENT_ORIGIN);
        }, 1000);
      } else {
        initKrpano(xml, targetView);
      }
    }

    // Called from krpano hotspot onclick - receives sceneId and optional target view
    function navigateToSceneFromKrpano(sceneId, targetView) {
      var sceneName = getSceneName(sceneId);
      
      // Send navigationStarted message IMMEDIATELY so Flutter can update the UI
      // H-2: use PARENT_ORIGIN, never '*'
      window.parent.postMessage({
        type: 'navigationStarted',
        scene: sceneId,
        name: sceneName
      }, PARENT_ORIGIN);
      
      // Then navigate to the scene
      navigateToScene(sceneId, sceneName, targetView || '');
    }

    // ===== INITIALIZE KRPANO =====
    function initKrpano(sceneXml, targetView) {
      removepano('krpanoSWFObject');

      embedpano({
        xml: STATIC_BASE + 'static/core/tour.xml',
        target: 'pano',
        html5: 'only',
        mobilescale: 1.0,
        passQueryParameters: true,
        bgcolor: '#000000',
        id: 'krpanoSWFObject',
        basepath: STATIC_BASE + 'static/',
        onready: function(krpano) {
          krpanoObj = krpano;
          tourReady = true;
          console.log('krpano engine ready');

          // Load the first scene XML with blend transition
          krpano.set('xmldata', sceneXml);
          krpano.call('loadxml(get(xmldata), null, MERGE, BLEND(0.5))');

          setTimeout(function() {
            loadingOverlay.classList.add('hidden');
            // H-2: use PARENT_ORIGIN, never '*'
            window.parent.postMessage({ 
              type: 'tourLoaded', 
              scene: currentScene,
              name: getSceneName(currentScene)
            }, PARENT_ORIGIN);
          }, 1500);
        }
      });
    }

    // ===== LISTEN FOR MESSAGES FROM FLUTTER =====
    // H-3: Only accept messages from our own origin (the Flutter app page).
    var PARENT_ORIGIN = (window.location.ancestorOrigins && window.location.ancestorOrigins.length > 0)
      ? window.location.ancestorOrigins[0]
      : document.referrer
        ? new URL(document.referrer).origin
        : window.location.origin;

    window.addEventListener('message', function(event) {
      // H-3: Reject messages from unexpected origins
      if (event.origin !== PARENT_ORIGIN) return;

      var data = event.data;
      if (!data) return;

      if (data.action === 'navigateToScene') {
        var sceneId = data.sceneId;
        var sceneName = data.sceneName || getSceneName(sceneId);
        console.log('Received navigation from Flutter:', sceneName);
        navigateToScene(sceneId, sceneName);
      }

      if (data.action === 'resetTour') {
        navigateToScene('6978265df7083ba3665904a6', 'NDMU Library');
      }
    });

    // ===== START =====
    var urlParams = new URLSearchParams(window.location.search);
    // Default to "NDMU Library" scene
    var initialSceneId = urlParams.get('scene') || '6978265df7083ba3665904a6';

    console.log('Panoee wrapper initialized (DIRECT krpano mode)');
    // H-2: use PARENT_ORIGIN so the ready signal only reaches our Flutter host
    window.parent.postMessage({ type: 'wrapperReady' }, PARENT_ORIGIN);

    loadTourData(function() {
      navigateToScene(initialSceneId, getSceneName(initialSceneId));
    });
  </script>
</body>
</html>